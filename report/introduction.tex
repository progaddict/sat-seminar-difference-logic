\section{Introduction}
\label{sec:introduction}



\subsection{Difference Logic}
DL is a special case of an LA logic in which
all LA constraints have the form $ x - y \prec c $ where
$ x $ and $ y $ are numerical variables, $ c $ is a constant
and $ \prec \in \{<, \leq \} $ is a comparison operator.
A more formal definition of DL is given
below~\cite{cotton2004some},~\cite[p.5]{mahfoudh2003verification}:
\begin{definition}[Difference Logic]
    Let $ \mathcal{B} = \{ b_1, b_2, \dots \} $ be a set of Boolean
    variables and $ \mathcal{X} = \{ x_1, x_2, \dots \} $ be a set
    of numerical variables. The difference logic over
    $ \mathcal{B} $ and $ \mathcal{X} $ is called
    $ DL(\mathcal{X},\mathcal{B}) $ and given by the following grammar:
    \begin{equation*}
        \phi \eqbydef b \; | \; (x - y < c) \; | \; \neg \phi \; | \;
        \phi \land \phi
    \end{equation*}
    where $ b \in \mathcal{B} $, $ x,y \in \mathcal{X} $ and
    $ c \in \mathbb{D} $ is a constant. The domain $ \mathbb{D} $ is
    either the integers $ \mathbb{Z} $ or the real numbers $ \mathbb{R} $.
    \\
    The remaining Boolean connectives
    $ \lor, \rightarrow, \leftrightarrow, \dots $ can be defined in
    the usual ways in terms of conjunction and negation.
\end{definition}
Examples of DL formulas are given below:
\begin{equation}
    \label{eq:example-1}
    \phi_1 = (p \lor q \lor r) \land (p \rightarrow (u - v < 3)) \land
    (q \rightarrow (v - w < -5)) \land (r \rightarrow (w - x < 0))
\end{equation}
\begin{equation}
    \label{eq:example-2}
    \phi_2 = (u-v < 1)
        \land (v-w < 5)
        \land (w-x \leq -3)
        \land (x-y < 1)
        \land (y-z \leq -5)
        \land (y-v \leq 0)
\end{equation}
\begin{equation}
    \label{eq:example-3}
    \phi_3 = (u-v < 1)
        \land (v-w < 5)
        \land (w-x \leq -3)
        \land (x-y < -3)
        \land (y-z \leq -5)
        \land (y-w < 4)
\end{equation}



\subsection{Solving SAT Problem of Propositional Logic}
Most of the SAT solvers employ a variation of the
Davis-Putnam-Logemann-Loveland (DPLL)
algorithm~\cite{davis1960computing, davis1962machine}
for solving SAT problem of the propositional logic (PL).
One such basic SAT checking algorithm is given below:
\begin{Algorithm}
    \caption{A basic SAT checking algorithm for solving SAT problem of PL.
        It takes a PL formula to be checked for satisfiability and
        returns SAT status of the formula (SAT or UNSAT)
        and, in case when the formula is SAT, a model \ie an assignment, which evaluates the formula to $ True $.}
    \label{alg:basic-sat}
    \begin{algorithm}{\text{(SAT Status, Model) Check}}
        {\text{PL formula} \phi}
        model \= \varnothing \\
        (inferredAssignments, conflictingClauses) \= \CALL{Propagate}(\phi, model) \\
        conflictHasArisen \= conflictingClauses \neq \varnothing \\
        \begin{IF}{conflictHasArisen}
            \RETURN (UNSAT, \NIL)
        \end{IF} \\
        model\=model \cup inferredAssignments \\
        \begin{WHILE}{True}
            (nextVariable, value) \= \CALL{Decide}(\phi, model) \\
            allVariablesHaveAlreadyBeenAssigned \= nextVariable = \NIL \\
            \begin{IF}{allVariablesHaveAlreadyBeenAssigned}
                \RETURN (SAT, model)
            \end{IF} \\
            model \= model \cup \{ nextVariable \= value \} \\
            \begin{REPEAT} \\
                (inferredAssignments, conflictingClauses) \= \CALL{Propagate}(\phi, model) \\
                model \= model \cup inferredAssignments \\
                conflictHasArisen \= conflictingClauses \neq \varnothing \\
                \begin{IF}{conflictHasArisen}
                    (newModelWithoutConflict, \phi_a) \= \CALL{Resolve}(\phi, model, conflictingClauses) \\
                    conflictHasNotBeenResolved \= newModelWithoutConflict = \NIL \\
                    \begin{IF}{conflictHasNotBeenResolved}
                        \RETURN (UNSAT, \NIL)
                    \end{IF} \\
                model \= newModelWithoutConflict \\
                \phi \= \phi \land \phi_a
                \end{IF}
            \end{REPEAT} \neg conflictHasArisen
        \end{WHILE}
    \end{algorithm}
\end{Algorithm}

The given above Algorithm~\ref{alg:basic-sat} is quite generic,
it is more of a template.
One needs to plug into this template his own implementations of the
following functions:

\begin{itemize}
    \item[$ \algCALL{Propagate} $] This function takes a PL formula
    and a model and returns all assignments that follow from
    them.
    It also returns a list of conflicting clauses (if there are any).
    These clauses will be in conflict with the model if one extends
    the model by applying the returned assignments.
    \item[$ \algCALL{Decide} $] This function takes a PL formula
    and a model. Then, by applying some heuristic, it
    selects a variable and a value for it and returns them.
    \item[\algCALL{Resolve}] This function takes a PL formula, current
    conflicting model and a list of the clauses which are in the conflict
    with the current model.
    It returns a new model which does not have the conflict and an assertion clause
    $ \phi_a $ (or a conjunction of assertion clauses) which carries the knowledge
    about the resolved conflict.
    If the conflict cannot be resolved, the function returns $ \algNIL $ as
    the model.
\end{itemize}

In the described above Algorithm~\ref{alg:basic-sat} a model is represented by
a mapping from PL variables of the input PL formula to Booleans.
It is a simplification.
Real SAT solvers maintain a lot of additional information such as decision
levels, assignment order of variables for every decision level, an implicant for
every variable (\ie the clause from which the variable's value was inferred during
the $ \algCALL{Propagate} $) \etc



\subsection{Solving SAT Problem of Difference Logic}
\begin{figure}[htb]
    \begin{center}
        \begin{tabular}{lr}
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \input{pictures/fig-lazy-approach.tex}
                \end{center}
            \end{minipage}
            &
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \input{pictures/fig-incremental-approach.tex}
                \end{center}
            \end{minipage}
        \end{tabular}
    \end{center}
    \caption{Illustration of the lazy (left) and incremental (right) approaches.}
    \label{fig:lazy-and-incremental-approaches}
\end{figure}
As mentioned in~\cite{cotton2004some} the following main approaches are used for
solving the SAT problem of DL:

\begin{itemize}
    \item Preprocessing approach. This approach suggests transforming a DL
    formula into an equivalent PL formula by encoding all intrinsic
    dependencies between DL constraints in PL.
    An example of such a dependency could be transitivity:
    \begin{equation}
        \label{eq:transitivity-example}
        (x-y<a) \land (y-z<b) \rightarrow (x-z<a+b)
    \end{equation}
    After the transformation a SAT solver can be used to check SAT of
    the resulting equivalent PL formula.
    If the PL formula is SAT then the solution for the original DL formula
    can be constructed by the reverse transformation.
    \item Lazy approach
    (Figure~\ref{fig:lazy-and-incremental-approaches} left).
    This approach suggests substituting each DL constraint $ x-y<c $ with
    a Boolean variable $ p_{xyc} \in \mathbb{B} $ thus yielding
    a PL formula~$ \phi' $.
    The PL formula represents the "skeleton", the Boolean abstraction over
    the original DL formula $ \phi $.
    Then a SAT solver is used in tandem with a DL constraints checker (the
    theory solver).
    \item Incremental approach
    (Figure~\ref{fig:lazy-and-incremental-approaches} right).
    This approach, like the previous one, also suggests encoding the input
    DL formula into a Boolean "skeleton" and
    a SAT solver and a DL constraints checker also work
    in tandem.
    However, instead of solving the whole formula and then giving a
    complete answer to the DL constraints checker, the SAT solver invokes
    the DL constraints checker each time it updates its model.
    The DL constraints checker should be able to maintain some internal
    state of the currently received DL constraints and update it
    incrementally (\ie add new constraints, delete existing ones).
    Hence the name of the approach.
\end{itemize}
