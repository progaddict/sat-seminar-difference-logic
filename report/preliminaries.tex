\section{Preliminaries}
\label{sec:preliminaries}



\subsection{Solving SAT Problem of Propositional Logic}
Most of the SAT solvers employ a variation of the
Davis-Putnam-Logemann-Loveland (DPLL)
algorithm~\cite{davis1960computing, davis1962machine}
for solving SAT problem of the propositional logic (PL).
One such basic SAT checking algorithm is given below.
\begin{Algorithm}
    \caption{A basic satisfiability checking algorithm for deciding
        satisfiability problem of propositional logic.}
    \label{alg:basic-sat}
    \begin{algorithm}{Check}{}
        \begin{IF}{! \: \CALL{Propagate}()}
            \RETURN UNSAT
        \end{IF} \\
        \begin{WHILE}{True}
            \begin{IF}{! \: \CALL{Theory}()}
                \begin{IF}{! \: \CALL{Resolve}()}
                    \RETURN UNSAT
                \end{IF}
                \ELSE
                \begin{IF}{! \: \CALL{Decide}()}
                    \RETURN SAT
                \end{IF}
            \end{IF} \\
            \begin{WHILE}{! \: \CALL{Propagate}()}
                \begin{IF}{! \: \CALL{Resolve}()}
                    \RETURN UNSAT
                \end{IF}
            \end{WHILE}
        \end{WHILE}
    \end{algorithm}
\end{Algorithm}

The Algorithm~\ref{alg:basic-sat} is quite generic.
It is more of a template.
One needs to plug into this template his own implementations of the
following functions:
\begin{itemize}
    \item[$ \algCALL{Propagate} $] This function calculates
    all assignments that follow from a given PL formula
    and a given model.
    It also returns a list of conflicting clauses (if there are any).
    These clauses will be in conflict if one extends
    the model by the returned assignments.
    \item[$ \algCALL{Decide} $] This function applies some heuristic and
    selects a variable to be set next and a value.
    \item[$ \algCALL{Resolve} $] This function tries to resolve a conflict.
    It returns a new model without the conflict and
    an asserting clause $ \phi_a $.
    If the conflict cannot be resolved, the function returns $ \algNIL $
    instead of the model.
    \item[$ \algCALL{Theory} $] This function tries to resolve a conflict.
    It returns a new model without the conflict and
    an asserting clause $ \phi_a $.
    If the conflict cannot be resolved, the function returns $ \algNIL $
    instead of the model.
\end{itemize}



\subsection{Approaches to Decide Satisfiability of Difference Logic}
\begin{figure}[htb]
    \begin{center}
        \begin{tabular}{lr}
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \input{pictures/fig-lazy-approach.tex}
                \end{center}
            \end{minipage}
            &
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \input{pictures/fig-incremental-approach.tex}
                \end{center}
            \end{minipage}
        \end{tabular}
    \end{center}
    \caption{Illustration of the lazy (left) and incremental (right) approaches.}
    \label{fig:lazy-and-incremental-approaches}
\end{figure}
\cite{cotton2004some} mentions the following main approaches for
solving SAT problem of DL:
\begin{itemize}
    \item Preprocessing approach. This approach suggests transforming a DL
    formula into an equivalent PL formula by encoding all intrinsic
    dependencies between DL constraints in PL.
    An example of such a dependency is transitivity:
    \begin{equation}
        \label{eq:transitivity-example}
        (x-y<a) \land (y-z<b) \rightarrow (x-z<a+b)
    \end{equation}
    After the transformation a SAT solver can be used to check SAT of
    the resulting equivalent PL formula.
    If the PL formula is SAT then the solution for the original DL formula
    can be constructed by the reverse transformation.
    \item Lazy approach
    (Figure~\ref{fig:lazy-and-incremental-approaches} left).
    This approach suggests substituting each DL constraint
    $ x-y \prec c $ with
    a Boolean variable $ p_{xyc} \in \mathbb{B} $ thus yielding
    a PL formula~$ \phi' $.
    $ \phi' $ represents the "skeleton", the Boolean abstraction over
    the original DL formula $ \phi $.
    Then a SAT solver is used in tandem with a DL constraints checker (the
    theory solver) to solve SAT problem.
    In this approach the SAT solver always computes a complete solution
    which is then passed to the theory solver.
    \item Incremental approach
    (Figure~\ref{fig:lazy-and-incremental-approaches} right).
    In~\cite{cotton2004some} this approach is used.
    It is very similar to the lazy one.
    However, instead of computing a complete solution,
    the SAT solver invokes the DL constraints checker
    each time it updates its model.
    The DL constraints checker should be able to maintain some internal
    state of the currently received DL constraints and update it
    incrementally (\ie add new constraints, delete existing ones).
    Hence the name of the approach.
\end{itemize}
