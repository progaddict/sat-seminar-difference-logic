\section{Preliminaries}
\label{sec:preliminaries}



\subsection{Solving SAT Problem of Propositional Logic}
Most of the SAT solvers employ a variation of the
Davis-Putnam-Logemann-Loveland (DPLL)
algorithm~\cite{davis1960computing, davis1962machine}
for solving SAT problem of the propositional logic (PL).
One such basic SAT checking algorithm is given below:
\begin{Algorithm}
    \caption{A basic SAT checking algorithm for solving SAT problem of PL.
        It takes a PL formula to be checked for SAT and
        returns SAT status of the formula (SAT or UNSAT).
        It also returns a model \ie an assignment, which evaluates
        the formula to $ True $, in case if the formula is SAT.}
    \label{alg:basic-sat}
    \begin{algorithm}{Check}
        {\text{PL formula} \phi}
        model \= \varnothing \\
        (inferredAssignments, conflictingClauses) \= \CALL{Propagate}(\phi, model) \\
        conflictHasArisen \= conflictingClauses \neq \varnothing \\
        \begin{IF}{conflictHasArisen}
            \RETURN (UNSAT, \NIL)
        \end{IF} \\
        model\=model \cup inferredAssignments \\
        \begin{WHILE}{True}
            (nextVariable, value) \= \CALL{Decide}(\phi, model) \\
            allVariablesHaveAlreadyBeenAssigned \= nextVariable = \NIL \\
            \begin{IF}{allVariablesHaveAlreadyBeenAssigned}
                \RETURN (SAT, model)
            \end{IF} \\
            model \= model \cup \{ nextVariable \= value \} \\
            \begin{REPEAT} \\
                (inferredAssignments, conflictingClauses) \= \CALL{Propagate}(\phi, model) \\
                model \= model \cup inferredAssignments \\
                conflictHasArisen \= conflictingClauses \neq \varnothing \\
                \begin{IF}{conflictHasArisen}
                    (newModelWithoutConflict, \phi_a) \= \CALL{Resolve}(\phi, model, conflictingClauses) \\
                    conflictHasNotBeenResolved \= newModelWithoutConflict = \NIL \\
                    \begin{IF}{conflictHasNotBeenResolved}
                        \RETURN (UNSAT, \NIL)
                    \end{IF} \\
                    model \= newModelWithoutConflict \\
                    \phi \= \phi \land \phi_a
                \end{IF}
            \end{REPEAT} \neg conflictHasArisen
        \end{WHILE}
    \end{algorithm}
\end{Algorithm}

The Algorithm~\ref{alg:basic-sat} is quite generic.
It is more of a template.
One needs to plug into this template his own implementations of the
following functions:
\begin{itemize}
    \item[$ \algCALL{Propagate} $] This function calculates
    all assignments that follow from a given PL formula
    and a given model.
    It also returns a list of conflicting clauses (if there are any).
    These clauses will be in conflict if one extends
    the model by the returned assignments.
    \item[$ \algCALL{Decide} $] This function applies some heuristic and
    selects a variable to be set next and a value.
    \item[\algCALL{Resolve}] This function resolves a conflict
    or returns $ \algNIL $ if it cannot be resolved.
\end{itemize}

In the Algorithm~\ref{alg:basic-sat} a model is represented by
a mapping from PL variables of the input PL formula to Booleans.
It is a simplification.
Real-world SAT solvers maintain a lot of additional information
such as decision levels, assignment order of variables for every
decision level, an implicant for
every variable (\ie the clause from which the variable's
value was inferred during the $ \algCALL{Propagate} $) \etc

Additionally, a care should be taken when resolving a conflict and
computing a new model.
The solver should make sure it visits each state associated with
a model once only.



\subsection{Solving SAT Problem of Difference Logic}
\begin{figure}[htb]
    \begin{center}
        \begin{tabular}{lr}
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \input{pictures/fig-lazy-approach.tex}
                \end{center}
            \end{minipage}
            &
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \input{pictures/fig-incremental-approach.tex}
                \end{center}
            \end{minipage}
        \end{tabular}
    \end{center}
    \caption{Illustration of the lazy (left) and incremental (right) approaches.}
    \label{fig:lazy-and-incremental-approaches}
\end{figure}
\cite{cotton2004some} mentions the following main approaches for
solving the SAT problem of DL:
\begin{itemize}
    \item Preprocessing approach. This approach suggests transforming a DL
    formula into an equivalent PL formula by encoding all intrinsic
    dependencies between DL constraints in PL.
    An example of such a dependency could be transitivity:
    \begin{equation}
        \label{eq:transitivity-example}
        (x-y<a) \land (y-z<b) \rightarrow (x-z<a+b)
    \end{equation}
    After the transformation a SAT solver can be used to check SAT of
    the resulting equivalent PL formula.
    If the PL formula is SAT then the solution for the original DL formula
    can be constructed by the reverse transformation.
    \item Lazy approach
    (Figure~\ref{fig:lazy-and-incremental-approaches} left).
    This approach suggests substituting each DL constraint $ x-y<c $ with
    a Boolean variable $ p_{xyc} \in \mathbb{B} $ thus yielding
    a PL formula~$ \phi' $.
    $ \phi' $ represents the "skeleton", the Boolean abstraction over
    the original DL formula $ \phi $.
    Then a SAT solver is used in tandem with a DL constraints checker (the
    theory solver) to solve the SAT problem.
    In this approach the SAT solver always computes a complete solution
    which is then passed to the theory solver.
    \item Incremental approach
    (Figure~\ref{fig:lazy-and-incremental-approaches} right).
    This approach is very similar to the lazy one.
    However, instead of computing a complete solution,
    the SAT solver invokes the DL constraints checker
    each time it updates its model.
    The DL constraints checker should be able to maintain some internal
    state of the currently received DL constraints and update it
    incrementally (\ie add new constraints, delete existing ones).
    Hence the name of the approach.
\end{itemize}
